// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 1. Core Tables - often referenced by many others and have few dependencies
model User {
  id               Int      @id @default(autoincrement())
  email            String   @unique @db.Text // メールアドレス
  password         String   @db.Text // パスワードhash
  username         String?  @db.Text // ユーザー名
  schoolId         Int?     // 学校ID, relates to UserEducationTable but no direct relation specified here
  year             Int?     // 学年
  class            Int?     // クラス
  date             DateTime @db.Date // 生年月日
  level            Int?     // アカウントレベル
  xp               Int?     // 総経験値
  sex              String?  @db.Text // 性別
  certificate      Boolean? // 学校の生徒認証
  totalLogin       Int?     // 総ログイン数
  continuousLogin  Int?     // 連続ログイン数

  userSubjectProgress UserSubjectProgress[]
  statusKohaku        StatusKohaku?
  groups              GroupUser[]
  groupReaders        GroupReader[]
  submissions         Submission[]
  questionAUsers      QuestionAUser[]
}

model UserEducation {
  id         Int    @id @default(autoincrement())
  schoolName String @db.Text
}

model Subject {
  id                  Int                 @id @default(autoincrement()) // 科目ID
  name                String              @db.Text // 科目名
  userSubjectProgress UserSubjectProgress[]
  questions           QuestionA[] // Implicit relation from Question A
}

model Difficulty {
  id           Int      @id @default(autoincrement()) // 難易度(科目)ID
  difficulty   String   @db.Text // 難易度(科目)
  xp           Int?     // 経験値量
  // The examples in "Difficulty_データ" seem to be values, not separate fields for the table.
  // "目安解答時間" is also a value, not a field.

  questionsB   QuestionB[]
  coding       Coding[]
  explanations Explanation[]
}

model Degree {
  id     Int     @id @default(autoincrement())
  degree String? @db.Text // 称号
}

model Group {
  id         Int      @id @default(autoincrement())
  readerId   Int      // readerid
  serverName String   @db.Text // servername
  body       String   @db.Text // body

  groupUsers     GroupUser[]
  groupReaders   GroupReader[]
  assignments    Assignment[]
}

// 2. Lookup/Shared Entities - often referenced, but don't heavily depend on others
model Genre {
  id         Int     @id @default(autoincrement()) // autsincrymené
  genreName  String  @db.Text // ジャンル名

  questionAGenres     QuestionAGenre[]
  questionAUserGenres QuestionAUserGenre[]
}

// 2. Lookup/Shared Entities - often referenced, but don't heavily depend on others
model Trace {
  id          Int      @id @default(autoincrement())
  questionAId Int      // Question Aとリレーション
  questionA   QuestionA @relation(fields: [questionAId], references: [id])
  line        Int?     // プログラムの行
  code        String?  @db.Text // その行のコード
  content     String?  @db.Text // 内容など

  questionB QuestionB[] // Relation "Traceテーブルとリレーシン" in Question B
}

model TestCase {
  id          Int     @id @default(autoincrement())
  questionId  Int?    // questionid
  // ここで、questionBの反対側のリレーションをQuestionBモデルに追加する必要があります。
  // mapは外部キーの名前ではなく、リレーション名を識別するために使われます。
  questionB   QuestionB? @relation("QuestionBToTestCase", fields: [questionId], references: [id])
  coding      Coding[]

  // The fields difficulty, xp, and time are listed under "Difficulty_データ" in the provided source
  // but also in "Test Case" block.
  // Assuming these are attributes of the test case itself related to its difficulty.
  difficultyName String? @db.Text // e.g., "やさしい", "かんたん"
  xpAmount       Int?
  estimatedTime  String? // e.g., "5分", "10分"
}

// 3. Models representing questions and answers (which depend on core tables and lookup tables)
// Define QuestionA and QuestionB before AnswerA and AnswerB as answers refer to questions
model QuestionA {
  id          Int       @id @default(autoincrement()) @map("Question_id") // Auto-increment for Question A
  title       String    @db.Text // 問題のタイトル
  imagePath   String?   @db.Text // 画像のディレクトリ預定
  releaseYear Int?      // 出 年
  subjectId   Int?      // Implicit relation to Subject based on overall context of subjects and questions
  subject     Subject?  @relation(fields: [subjectId], references: [id])

  answersA       AnswerA[]
  traces         Trace[]
  genres         QuestionAGenre[]
  questionAUsers QuestionAUser[]
}

model QuestionB {
  id          Int         @id @default(autoincrement())
  title       String      @db.Text // タイトル
  questionText String     @db.Text // 問題文
  imagePath   String?     @db.Text // 画像のディレクトリ指定
  difficultyId Int?       // Difficulty relation
  difficulty  Difficulty? @relation(fields: [difficultyId], references: [id])
  trace       Trace?      @relation(fields: [traceId], references: [id]) // Traceテーブルとリレーシン
  traceId     Int?

  answersB  AnswerB[]
  // こちら側もリレーション名を指定し、TestCaseのquestionBフィールドに対応させます。
  // 外部キーはTestCase側にあるため、ここではfieldsとreferencesは不要です。
  testCases TestCase[] @relation("QuestionBToTestCase")
}

model AnswerA {
  id              Int            @id @default(autoincrement()) @map("Answer_id") // Awer A
  questionAId     Int?           // Question A リレーション
  questionA       QuestionA?     @relation(fields: [questionAId], references: [id])
  questionAUserId Int?
  questionAUser   QuestionAUser? @relation(fields: [questionAUserId], references: [id])
  charValue       String?        @db.Text // cha (for single character/choice)
  selectionText   String?        @db.Text // 選択 文章
  isCorrect       Boolean?       // 正解 不正解
  freeText        String?        @db.Text // 文章 (for free text answer)
}

model AnswerB {
  id          Int       @id @default(autoincrement())
  questionBId Int       // question it
  questionB   QuestionB @relation(fields: [questionBId], references: [id])
  symbol      String?   @db.Text // symbal
  content     String?   @db.Text // contect (for text answers)
  isCorrect   Boolean?  // 正解 不正解 (assuming boolean)
}

// 4. Junction Tables (Many-to-many relationships) - these typically depend on models from group 1, 2, or 3
model UserSubjectProgress {
  userId    Int
  user      User    @relation(fields: [userId], references: [id])
  subjectId Int
  subject   Subject @relation(fields: [subjectId], references: [id])
  level     Int?    // 科目ごとのランク
  xp        Int?    // 科目ごとの経験値

  @@id([userId, subjectId]) // Composite primary key
}

model QuestionAGenre {
  questionAId Int
  questionA   QuestionA @relation(fields: [questionAId], references: [id])
  genreId     Int
  genre       Genre     @relation(fields: [genreId], references: [id])

  @@id([questionAId, genreId])
}

model QuestionAUser {
  id          Int       @id @default(autoincrement()) // autonoryment
  userId      Int       // Assuming it relates to a user who answered this question
  user        User      @relation(fields: [userId], references: [id])
  questionAId Int       // Question A リレーション
  questionA   QuestionA @relation(fields: [questionAId], references: [id])
  title       String?   @db.Text // のタイトル
  imagePath   String?   @db.Text // のディレクトリ
  releaseTime String?   @db.Text // 出時期( )
  release     String?   @db.Text // 出

  genres  QuestionAUserGenre[]
  answers AnswerA[] // wer カテーブルとリレーション
}

model QuestionAUserGenre {
  questionAUserId Int
  questionAUser   QuestionAUser @relation(fields: [questionAUserId], references: [id])
  genreId         Int
  genre           Genre         @relation(fields: [genreId], references: [id])

  @@id([questionAUserId, genreId])
}

// 5. Other Transactional/Related Tables - these often depend on many of the above
model StatusKohaku {
  id        Int     @id @default(autoincrement())
  userId    Int     @unique // ユーザー名, assuming one status per user
  user      User    @relation(fields: [userId], references: [id])
  status    String? @db.Text // コハクの状態
  huberLevel Int?    // コハクの空腹ゲージ
  response  String? @db.Text // ステータスに応じた受け答え (assuming this is the field with type str)
}

model GroupUser {
  id           Int      @id @default(autoincrement())
  userId       Int      // userid
  user         User     @relation(fields: [userId], references: [id])
  groupId      Int      // groupid
  group        Group    @relation(fields: [groupId], references: [id])
  assiSubmission Boolean? // assi submission

  @@unique([userId, groupId]) // Assuming a user can only be in a group once
}

model GroupReader {
  id      Int   @id @default(autoincrement())
  userId  Int   // userid
  user    User  @relation(fields: [userId], references: [id])
  groupId Int   // groupid
  group   Group @relation(fields: [groupId], references: [id])

  @@unique([userId, groupId]) // Assuming a user can only be a reader for a group once
}

model Assignment {
  id          Int       @id @default(autoincrement())
  groupId     Int       // groupid
  group       Group     @relation(fields: [groupId], references: [id])
  title       String    @db.Text // title
  description String?   @db.Text // description
  dueDate     DateTime  @db.Timestamp(6) // due date
  createdAt   DateTime  @default(now()) @db.Timestamp(6) // created at
  updatedAt   DateTime  @updatedAt @db.Timestamp(6) // updated at

  submissions Submission[]
}

model Submission {
  id           Int        @id @default(autoincrement())
  assignmentId Int        // assignment_id
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  userId       Int        // userid
  user         User       @relation(fields: [userId], references: [id])
  description  String?    @db.Text // description
  status       String?    @db.Text // status
  codingId     Int?       // codingid, assuming relation to a Coding table, but not explicitly defined in file
  submittedAt  DateTime   @db.Timestamp(6) // submitted at
  createdAt    DateTime   @default(now()) @db.Timestamp(6) // created at
  updatedAt    DateTime   @updatedAt @db.Timestamp(6) // updated at

  submissionFiles SubmissionFile[]
}

model SubmissionFile {
  id           Int      @id @default(autoincrement())
  submissionId Int      // submissionid
  submission   Submission @relation(fields: [submissionId], references: [id])
  filename     String   @db.Text // filename
  filepath     String   @db.Text // filepath
  filesize     Int?     // filesize
  uploadedAt   DateTime @default(now()) @db.Timestamp(6) // uploaded_at
}

model Explanation {
  id           Int      @id @default(autoincrement())
  difficultyId Int?     // difficulty
  difficulty   Difficulty? @relation(fields: [difficultyId], references: [id])
  imagePath    String?  @db.Text // 画像
  content      String?  @db.Text // Based on context, this would be the explanation text
}

model Coding {
  id          Int         @id @default(autoincrement()) // テストケーステーブルのd
  testCaseId  Int?        // Test Case ID relation, but Test Case table also has difficulty and XP
  testCase    TestCase?   @relation(fields: [testCaseId], references: [id])
  difficultyId Int?       // difficulty
  difficulty  Difficulty? @relation(fields: [difficultyId], references: [id])
  // Additional fields for coding problem description, etc.
}