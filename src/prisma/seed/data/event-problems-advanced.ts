export const advancedProblems = [
    {
        title: '【上級】 クレジットカード番号検証 (Luhnアルゴリズム)',
        description: `【問題16】
クレジットカード番号の整合性チェック（Luhnアルゴリズム変種）を行い、
それぞれの番号に対して条件を満たすように1桁目に入る正しい数字を求めて出力しなさい。`,
        problemType: 'コーディング問題',
        difficulty: 5,
        timeLimit: 60,
        category: 'アルゴリズム',
        topic: '数値計算',
        tags: '["C言語", "イベント", "上級", "アルゴリズム"]',
        codeTemplate: `#include <stdio.h>

int main(void){
    unsigned long int src[][2] ={
        {62838102,61489910}, {51107010,51767150}, {27349251, 4508130}, 
        {67089197,96163500}, {75406678,37018290}, {48183241, 7270570}, 
        {18414708,63474250}, {20451400,59613860}, {64834311,70308900}, 
        {83451146,48759850}, {47939707,38527800}, {83060753,28201180}, 
        {57770685,15721410}, {85143075,21850640}, {10249573,25163310},
        {92091414,41097070}, {54147109,86723490}, {59828395,13251220}, 
        {35590802,33256540}, {50098439,44594370}, {78034990,31137980}, 
        {72335551,48330630}, {19682899,72338250}, {36422501,96388500}, 
        {86719436,87711680}, {68904321,29442500}, {82723484,29741740}, 
        {14847868,67362260}, {20719539,89339500}, {56163685,49193930},
        {77320759,19800480}, {37062007,68421110}, {44757279,19010600}, 
        {83680837,15829190}, {33006429,75415220}, {37598550, 3474870}, 
        {80044530,37208920}, {45972227,60366680}, {49164051,55873710}, 
        {70878624,53244380}, {74219409,57437720}, {75699120,66896560}, 
        {78083170,69277050}, {99204816,93863390}, {48452276,39819600},
        {6673404,26472530}, {62274330,16794500}, {94946965,42945980}, 
        {80709280,81077550}, {18974159,62806690}
    };
　　// 処理
    return 0;
}`,
        isPublic: false,
        isPublished: true,
        sampleCases: [
            {
                input: '(データ例)',
                expectedOutput: `5
9
7`,
                description: '実行結果の例',
                order: 1
            }
        ],
        testCases: [
            {
                input: '',
                expectedOutput: `5
9
7
2
8
9
6
6
2
6
0
7
0
5
0
0
5
5
5
6
5
9
2
7
1
0
4
8
2
2
4
4
9
3
5
5
3
3
0
0
9
8
8
1
6
0
2
4
4
5`,
                name: 'テストケース1',
                order: 1
            }
        ]
    },
    {
        title: '【上級】 島の数 (DFS/BFS)',
        description: `【問題17】
char型の2次元配列 land には以下のような10桁x10行の文字列が入っています。
..##......
....###...
....###...
.##.......
.##.......
....##....
....##..##
....#####.
..........
..........
これは 10 x 10 マスの地図データで . は海、 # は陸地を表わすものとします。
さらにこのマスの周囲は全て海で囲まれているものとします。
陸地同士が上下左右のいずれかの方向で隣り合っている陸地は繋がっているとみなし、
斜め方向でのみ隣り合っている場合は繋がっているとはみなしません。
海に囲まれている繋がった陸地の固まりを１つの島として扱うとき、島の数を求めて出力しなさい。
`,
        problemType: 'コーディング問題',
        difficulty: 5,
        timeLimit: 45,
        category: 'アルゴリズム',
        topic: '探索',
        tags: '["C言語", "イベント", "上級", "DFS", "探索"]',
        codeTemplate: `#include <stdio.h>

int main(void) {
    char land[10][11] = {
        "..##......",
        "....###...",
        "....###...",
        ".##.......",
        ".##.......",
        "....##....",
        "....##..##",
        "....#####.",
        "..........",
        ".........."
    };
    
    // 島の数を数える処理
    return 0;
}`,
        isPublic: false,
        isPublished: true,
        testCases: [
            {
                input: '',
                expectedOutput: '4',
                name: 'テストケース1',
                order: 1
            }
        ]
    },
    {
        title: '【上級】 画像処理 (ヒストグラム)',
        description: `【問題18】
image.ppm は、PPM(Portable Pixelmap)と呼ばれる形式で保存された画像です。

PPMの画像フォーマットは以下のようになっています。

------------------
P6
<XSIZE> <YSIZE>
<最大階調値>
<画像データ>
------------------
1行目：ASCII文字で、固定で「P6」が入ります。
2行目：ASCII文字で、画像の横サイズ（Pixel）、縦サイズ（Pixel）が半角スペース区切りで入ります。
       <XSIZE>×<YSIZE>は、最大 65536 Pixel
3行目：ASCII文字で、画像の最大階調値（1 ～ 255）が入ります。
4行目：バイナリで、RGBRGB・・・が続きます。R,G,Bは、それぞれ 1 バイト

1 ～ 3行目の改行は、LF（0x0A）になります。

データ化すると以下のようになる。
char image[] =	{'P','6','\\0x0a',
<XSIZE>,' ',<YSIZE>,'\\0x0a',
<最大諧調値>,'\\0x0a',
R,G,B,R,G,B.....};


このデータに対し、以下の順番で処理してください。
（1）画像をグレイスケール化
      ※グレイスケール階調の計算： ( R + G + B ) / 3.0 の結果を小数点第１位で四捨五入、整数化する。
（2）0 ～ <最大階調値>階調のヒストグラム（それぞれの階調毎の Pixel 数）を計算
      ※（２）で計算したグレイスケールの階調 0 ～ <最大階調値> に対し、それぞれ何 Pixel あるか集計する。
（3）ヒストグラムデータの中で最大値 <M> を見つける。
（4）ヒストグラムデータに対し、20 / <M> を掛け、小数以下を切り捨て、数値の数だけ「*」を出力
      1 階調データに対し、1 行出力します。
      最大で、「*」が 20 個になります。
`,
        problemType: 'コーディング問題',
        difficulty: 5,
        timeLimit: 60,
        category: 'アルゴリズム',
        topic: '画像処理',
        tags: '["C言語", "イベント", "上級", "画像処理", "ポインタ"]',
        codeTemplate: `#include <stdio.h>

int main(void) {
    char image[] = {
        'P','6','\x0a','8',' ','8','\x0a',
        '2','5','5','\x0a',
        208,223,140,206,218,133,205,214,129,205,210,128,
        206,205,129,206,202,131,208,198,135,209,193,140,
        210,219,146,208,215,139,207,210,136,208,206,136,
        209,199,138,210,195,140,211,191,144,213,186,148,
        213,217,153,211,211,147,210,206,144,210,199,145,
        211,194,146,213,188,149,215,181,154,216,176,158,
        215,214,161,213,207,155,213,200,153,214,194,153,
        215,187,156,216,181,158,218,172,162,219,166,166,
        218,211,167,217,203,164,217,196,162,217,189,161,
        218,181,163,219,172,166,221,163,171,223,156,175,
        221,208,176,220,200,171,220,191,169,220,182,170,
        221,173,172,223,164,174,224,154,178,226,145,182,
        224,205,183,223,196,180,223,187,177,223,176,178,
        224,167,179,226,155,182,227,145,185,228,137,187,
        227,203,189,227,193,187,226,183,185,226,171,185,
        227,161,186,228,148,188,230,138,190,231,129,192,
    };

    // 処理
    return 0;
}`,
        isPublic: false,
        isPublished: true,
        sampleCases: [
            {
                input: `P6
2 2
2
<0><2><0><1><1><1><2><2><2><0><0><0>`,
                expectedOutput: '(ヒストグラムが出力されます)',
                description: '画像データ(2 x 2 Pixcel、最大階調値 2 = 0 ～ 2 の全 3 階調)',
                order: 1
            }
        ],
        testCases: [
            {
                input: '',
                expectedOutput: `********
*****
***********
**************
********************
**************
**************
**************
*****
********
********
*****
***********
**
*****
**
**
*****
**
**
**
*****
**
**`,
                name: 'テストケース1',
                order: 1
            }
        ]
    },
    {
        title: '【上級】 ハノイの塔 (状態特定)',
        description: `【問題19】
ハノイの塔というパズルがあります。

3つの柱があり、左から順にA,B,Cの柱とします。
柱に通す事が出来る穴が中心に空いている円盤が n 個用意されています。
全ての円盤は異なる直径を持ち、柱Aに全ての円盤が下から大きい順に重なっています。

以下のルールを守って円盤を全て柱Cへ移動させる事がパズルの目的です。
・円盤を重ねる時、1つ上の円盤は下の円盤より小さくなくてはならない
・重なっている円盤を複数まとめて移動することは出来ない


例えば3つの円盤が入力として与えられ、柱Aの下から円盤3,円盤2,円盤1と名付けた場合、
その時の最短手順は以下の通りになります。

1. 円盤1を柱Aから柱Cへ移動
2. 円盤2を柱Aから柱Bへ移動
3. 円盤1を柱Cから柱Bへ移動
4. 円盤3を柱Aから柱Cへ移動
5. 円盤1を柱Bから柱Aへ移動
6. 円盤2を柱Bから柱Cへ移動
7. 円盤1を柱Aから柱Cへ移動

この時、円盤の数に寄らず最短手順は常に一意に決まります。
(分かりづらい場合は図を書いてみましょう。)


1つも動かしていない状態を t = 0 とし、円盤を動かした回数を t　とします。
円盤の数 n と、円盤を動かした回数 t が与えられるので n 個の円盤を最短手順で動かしていった時に円盤を動かした回数 t の状態を以下の形式で出力してください。

円盤を小さい順に 1, 2, 3 ..., n と表し、
1行目 : 柱Aに重なっている円盤を下から順にスペース区切りで出力
2行目 : 柱Bに重なっている円盤を下から順にスペース区切りで出力
3行目 : 柱Cに重なっている円盤を下から順にスペース区切りで出力`,
        problemType: 'コーディング問題',
        difficulty: 5,
        timeLimit: 60,
        category: 'アルゴリズム',
        topic: '再帰',
        tags: '["C言語", "イベント", "上級", "再帰", "ハノイの塔"]',
        codeTemplate: `#include <stdio.h>

int main(void) {
    int n = 8;
    int t = 65;
    
    // 処理
    return 0;
}`,
        isPublic: false,
        isPublished: true,
        sampleCases: [
            {
                input: 'n = 3, t = 4',
                expectedOutput: `2 1

3`,
                description: '例 : n = 3, t = 4 の時の出力結果',
                order: 1
            }
        ],
        testCases: [
            {
                input: '',
                expectedOutput: `8 1
7
6 5 4 3 2`,
                name: 'テストケース1',
                order: 1
            }
        ]
    },
    {
        title: '【上級】 GPIO制御 (埋め込み)',
        description: `【問題20】
GPIOの制御を行うプログラムを作成する。

以下GPIO仕様
------------------------------
アドレス配置
Address	Field Name	Description	R/W
0x7E200000	GPFSEL0	GPIO Function Select 0	R/W
0x7E200004	GPFSEL1	GPIO Function Select 1	R/W
0x7E200008	GPFSEL2	GPIO Function Select 2	R/W
0x7E20000C	GPFSEL3	GPIO Function Select 3	R/W
0x7E200010	GPFSEL4	GPIO Function Select 4	R/W
0x7E200014	GPFSEL5	GPIO Function Select 5	R/W
0x7E200018	-	Reserved	-
0x7E20001C	GPSET0	GPIO Pin Output Set 0	W
0x7E200020	GPSET1	GPIO Pin Output Set 1	W
0x7E200024	-	Reserved	-
0x7E200028	GPCLR0	GPIO Pin Output Clear 0	W
0x7E20002C	GPCLR1	GPIO Pin Output Clear 1	W
...	...	...	...

データ配置
Range (bit)	Description	R/W	R
31 - 30	Reserved	-	-
29 - 27	FSEL8 FSEL9 - Function Select 9	R/W	0
26 - 24	FSEL8 FSEL8 - Function Select 8	R/W	0
23 - 21	FSEL7 FSEL7 - Function Select 7	R/W	0
20 - 18	FSEL6 FSEL6 - Function Select 6	R/W	0
17 - 15	FSEL5 FSEL5 - Function Select 5	R/W	0
14 - 12	FSEL4 FSEL4 - Function Select 4	R/W	0
11 - 9	FSEL3 FSEL3 - Function Select 3	R/W	0
8 - 6	FSEL2 FSEL2 - Function Select 2	R/W	0
5 - 1	FSEL1 FSEL1 - Function Select 1	R/W	0
2 - 0	FSEL0 FSEL0 - Function Select 0	R/W	0

入出力データ仕様
Bit	Description
000	GPIO Pin is an input
001	GPIO Pin is an output
------------------------------

GPIOは54ポート
    GPIO00 ～ GPIO09は、アドレス0x7E200000に対応。
    下位から3ビットづつで各ポートは設定される。
    **99 9888 7776 6655 5444 3332 2211 1000

GPIOに対応したアドレスに値を書き込んで制御する。
    3 bitのフラグでGPIOの機能を選する。
        0b 000 GPIOを入力に設定。
        0b 001 GPIOを出力に設定。

GPIOをON(HIGH)するときにはOutputSetの所定ビットに1を書く
GPIOをOFF(LOW)するときにはOutputClearの所定ビットに0を書く


(問題)
今回GPIO 23番に接続された制御確認用LEDをON,OFFする。
ONをする関数 LedOnと OFFをする関数 LedOffを作成せよ。
ONOFFを確認する関数 CheckIO を作成せよ

GPIOに関しては、セキュリティ制限はかかっておらず、
通常のメモリと同様にアクセスできるものとする。
またポートの設定は変更するまで維持されるものとする。
動作はON→OFFの順で行われる。

LedOn仕様
出力 なし
引数 なし
内容 GPIO23のポートを出力に設定し、ポートの電圧をHIGHにセット
     GPIO23のポート設定をもどす

LedOff仕様
出力 なし
引数 なし
内容 GPIO23のポートを出力に設定し、ポートの電圧をLOWにセット
     GPIO23のポート設定をもどす

CheckIO仕様
出力 整数型: LED点灯中(ポートHIGH)=1,LED消灯中(ポートLOW)=0
引数 整数型: ポート番号(0~54)
内容 ポートにセットされた内容より、LEDの様子を確認する。
     LedOnとLedOffと必ずセットで使用され、二つの関数より後に呼ばれる。`,
        problemType: 'コーディング問題',
        difficulty: 5,
        timeLimit: 45,
        category: '組み込み',
        topic: 'ハードウェア制御',
        tags: '["C言語", "イベント", "上級", "GPIO", "組み込み"]',
        codeTemplate: `#include <stdio.h>

void LedOn(void);
void LedOff(void);
int CheckIO(int port);

int main(void) {
    LedOn();
    if(CheckIO(23) == 1) printf("ON\\n");
    LedOff();
    if(CheckIO(23) == 0) printf("OFF\\n");
    return 0;
}

void LedOn(void) {
    // 実装
}

void LedOff(void) {
    // 実装
}

int CheckIO(int port) {
    // 実装
    return 0;
}`,
        isPublic: false,
        isPublished: true,
        testCases: [
            {
                input: '',
                expectedOutput: `ON
OFF`,
                name: 'テストケース1',
                description: '擬似動作チェック',
                order: 1
            }
        ]
    }
];
